---
phase: 01-foundation-auth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db.ts
  - schema.sql
  - app/api/auth/register/route.ts
  - app/api/auth/login/route.ts
  - app/api/auth/logout/route.ts
  - lib/auth.ts
  - middleware.ts
autonomous: true

must_haves:
  truths:
    - "User can register with email and password"
    - "User can log in with credentials"
    - "JWT token is generated and stored in HTTP-only cookie"
    - "User session persists across page refresh"
    - "Protected routes verify JWT before granting access"
    - "Passwords are hashed using bcrypt (never plain text)"
  artifacts:
    - path: "lib/db.ts"
      provides: "SQLite connection and query functions"
      exports: ["getDb", "query", "run"]
    - path: "schema.sql"
      provides: "User table definition"
      contains: "CREATE TABLE users"
    - path: "app/api/auth/register/route.ts"
      provides: "User registration endpoint"
      exports: ["POST"]
    - path: "app/api/auth/login/route.ts"
      provides: "User authentication endpoint"
      exports: ["POST"]
    - path: "app/api/auth/logout/route.ts"
      provides: "User logout endpoint"
      exports: ["POST"]
    - path: "lib/auth.ts"
      provides: "JWT utilities"
      exports: ["signToken", "verifyToken", "hashPassword", "comparePassword"]
    - path: "middleware.ts"
      provides: "Route protection logic"
      exports: ["middleware", "config"]
  key_links:
    - from: "app/api/auth/register/route.ts"
      to: "lib/auth.ts:hashPassword"
      via: "bcrypt hashing"
      pattern: "hashPassword\\("
    - from: "app/api/auth/login/route.ts"
      to: "lib/auth.ts:signToken"
      via: "JWT generation"
      pattern: "signToken\\("
    - from: "middleware.ts"
      to: "lib/auth.ts:verifyToken"
      via: "JWT verification"
      pattern: "verifyToken\\("
    - from: "app/api/auth/*/route.ts"
      to: "lib/db.ts"
      via: "database queries"
      pattern: "query\\(|run\\("
---

<objective>
Implement complete authentication backend: SQLite database, registration/login/logout API routes, JWT token management, and route protection middleware.

Purpose: Establish secure user authentication foundation for the entire application.
Output: Working auth system ready for frontend integration.
</objective>

<execution_context>
@D:\.claude\get-shit-done\workflows\execute-plan.md
@D:\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@D:\Capstone\.planning\PROJECT.md
@D:\Capstone\.planning\ROADMAP.md
@D:\Capstone\.planning\STATE.md

This is a greenfield Next.js project. No existing codebase - creating from scratch.

Stack decisions from STATE.md:
- Next.js App Router (not Pages Router)
- SQLite for user credentials and auth data
- Bcrypt for password hashing (industry standard)
- JWT tokens in HTTP-only cookies (secure, prevents XSS)
- Roll number extracted from username (format: email prefix must contain roll number for linking to MongoDB academic data)
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQLite Database Setup</name>
  <files>
    lib/db.ts
    schema.sql
  </files>
  <action>
Initialize SQLite database with better-sqlite3 (synchronous, faster for local dev).

Create `schema.sql`:
- User table: id (INTEGER PRIMARY KEY), email (TEXT UNIQUE), password (TEXT hashed), rollNumber (TEXT extracted from email), createdAt (TEXT ISO timestamp)
- Index on email for fast lookups

Create `lib/db.ts`:
- Export getDb() function that returns better-sqlite3 Database instance
- Export query() helper for SELECT statements
- Export run() helper for INSERT/UPDATE/DELETE
- Auto-initialize database and run schema.sql on first import
- Store database file at `data/auth.db` (create data directory if needed)

Use better-sqlite3 (NOT sqlite3) - it's synchronous and works better with Next.js App Router serverless functions.

Install: `npm install better-sqlite3` and `npm install -D @types/better-sqlite3`
  </action>
  <verify>
Verify files exist and TypeScript compiles:
```bash
ls lib/db.ts schema.sql
npm run build
```

Build should succeed without TypeScript errors. Database file `data/auth.db` will be created on first API call.
  </verify>
  <done>
SQLite database initialized with User table. Connection helper functions exported from lib/db.ts. Database file created at data/auth.db.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth Utility Functions</name>
  <files>
    lib/auth.ts
  </files>
  <action>
Create JWT and password hashing utilities.

Export these functions:
- `hashPassword(password: string): Promise<string>` - uses bcrypt.hash with 10 rounds
- `comparePassword(password: string, hash: string): Promise<boolean>` - uses bcrypt.compare
- `signToken(payload: {userId: number, email: string, rollNumber: string}): string` - creates JWT with 7-day expiry, uses HS256 algorithm
- `verifyToken(token: string): {userId: number, email: string, rollNumber: string} | null` - verifies JWT, returns payload or null if invalid/expired

Use jsonwebtoken library (NOT jose - better for server-side Node.js).

JWT secret: Use `process.env.JWT_SECRET || 'dev-secret-change-in-production'` (fallback for local dev).

Extract roll number from email: Assume email format is `rollnumber@domain.com` where roll number is the entire local part before @.

Install: `npm install bcrypt jsonwebtoken` and `npm install -D @types/bcrypt @types/jsonwebtoken`
  </action>
  <verify>
Verify file exists and TypeScript compiles:
```bash
ls lib/auth.ts
npm run build
```

Build should succeed. Auth functions will be tested via API routes in Task 3.
  </verify>
  <done>
Auth utility functions exported. Passwords can be hashed with bcrypt. JWTs can be signed and verified. Roll number extraction logic implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Registration, Login, and Logout API Routes</name>
  <files>
    app/api/auth/register/route.ts
    app/api/auth/login/route.ts
    app/api/auth/logout/route.ts
  </files>
  <action>
Create three API routes using Next.js App Router convention.

**app/api/auth/register/route.ts:**
- Export async POST function
- Accept JSON body: {email, password}
- Validate: email format, password min 8 chars
- Check if email already exists (query users table)
- Hash password using hashPassword()
- Extract roll number from email (local part before @)
- Insert user: run() with INSERT statement
- Return 201 with {message: "User created"}
- Return 400 for validation errors, 409 if email exists

**app/api/auth/login/route.ts:**
- Export async POST function
- Accept JSON body: {email, password}
- Query user by email
- Return 401 if user not found
- Compare password using comparePassword()
- Return 401 if password incorrect
- Sign JWT with {userId: user.id, email: user.email, rollNumber: user.rollNumber}
- Set HTTP-only cookie: `token=${jwt}; HttpOnly; Path=/; Max-Age=604800; SameSite=Lax`
- Return 200 with {message: "Logged in", user: {email, rollNumber}}

**app/api/auth/logout/route.ts:**
- Export async POST function
- Clear cookie: Set-Cookie with token=; Max-Age=0
- Return 200 with {message: "Logged out"}

Use NextResponse.json() for responses and cookies.set() for cookie management.

Error handling: try/catch with 500 on unexpected errors.
  </action>
  <verify>
Run:
```bash
npm run dev
curl -X POST http://localhost:3000/api/auth/register -H "Content-Type: application/json" -d '{"email":"2021001@college.edu","password":"testpass123"}'
curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"email":"2021001@college.edu","password":"testpass123"}' -c cookies.txt
```

Register should return 201. Login should return 200 with Set-Cookie header containing JWT.
  </verify>
  <done>
Registration endpoint creates users with hashed passwords. Login endpoint authenticates and sets JWT cookie. Logout endpoint clears cookie. Roll number is extracted from email and stored.
  </done>
</task>

<task type="auto">
  <name>Task 4: Route Protection Middleware</name>
  <files>
    middleware.ts
  </files>
  <action>
Create Next.js middleware to protect routes.

Export middleware function:
- Read token from cookies
- If no token and path starts with `/dashboard`: redirect to `/login`
- If token exists: verify using verifyToken()
- If token invalid and path starts with `/dashboard`: redirect to `/login`
- If token valid: allow request to continue
- If path is `/login` or `/register` and user has valid token: redirect to `/dashboard` (already logged in)

Export config object:
- matcher: `['/((?!api|_next/static|_next/image|favicon.ico).*)']` (runs on all pages except API routes and static assets)

Use NextResponse.redirect() for redirects and NextResponse.next() to continue.

Read cookie using `request.cookies.get('token')?.value`.
  </action>
  <verify>
With dev server running and logged in (token cookie set):
- Visit http://localhost:3000/dashboard → should NOT redirect (middleware allows)
- Clear cookies and visit http://localhost:3000/dashboard → should redirect to /login

Check in browser Network tab that middleware is running (no 404s, proper redirects).
  </verify>
  <done>
Middleware protects /dashboard routes by verifying JWT. Unauthenticated requests are redirected to /login. Authenticated users trying to access /login or /register are redirected to /dashboard.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Database initialized: `ls data/auth.db` should exist
2. API routes respond correctly:
   - POST /api/auth/register creates user
   - POST /api/auth/login returns JWT cookie
   - POST /api/auth/logout clears cookie
3. Middleware protects routes:
   - /dashboard requires authentication
   - Invalid token redirects to /login
4. Password security:
   - Open `data/auth.db` with SQLite viewer
   - Check users table: password column should contain bcrypt hash (starts with `$2b$`), NOT plain text
</verification>

<success_criteria>
- User credentials stored in SQLite with hashed passwords (AUTH-01, AUTH-02, DATA-01)
- Login endpoint authenticates and generates JWT (AUTH-03, AUTH-04)
- JWT stored in HTTP-only cookie with 7-day expiry (AUTH-05, AUTH-06)
- Middleware verifies JWT before allowing access to protected routes (AUTH-07)
- Roll number extracted from email and stored for future MongoDB linkage
- All API routes handle errors gracefully with appropriate status codes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-auth/01-01-SUMMARY.md`
</output>
